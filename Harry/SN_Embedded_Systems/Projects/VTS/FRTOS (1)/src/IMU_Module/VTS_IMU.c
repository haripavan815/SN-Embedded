/************************************************************************************************************************************/
/*																																	*/
/*  File Name:   VTS_IMU.c	
/*																							                                        */
/*  Description:   Contains IMU Initialization, I2C functionalities and reading accelerometer and gyro meter Readings.															*/
/*																																	*/
/*  -----------------------------------------------------------------------------------------------------------------------------   */
/*  |  Author              |    Date      | Rev  |									Comments								|		*/
/*  -----------------------------------------------------------------------------------------------------------------------------	*/
/*  | Somashekar N		   |              | 1.0  |			Created													        |	    */
/*  | Harish N  		   |  22-09-2022  | 1.0  |			Added IMU Initialization, I2C functionalities 
/*                                                                           											            */
/*------------------------------------------------------------------------------------------------------------------------------	*/
/*																																	*/
/*  Copyright (c) 2021, SNES																										*/
/*  All rights reserved.																											*/
/*																																    */
/************************************************************************************************************************************/
#include <asf.h>
#include "IMU_Module/VTS_IMU.h"

extern volatile bool IsIMUInitalised;

//  brief Wait for the given number of milliseconds (using the dwTimeStamp generated by the SAM microcontrollers' system tick).
//  param ul_dly_ticks  Delay to wait for, in milliseconds.

 void mdelay(uint32_t ul_dly_ticks)
{
	int i;
	/*uint32_t ul_cur_ticks;

	ul_cur_ticks = g_ul_ms_ticks;
	while ((g_ul_ms_ticks - ul_cur_ticks) < ul_dly_ticks);*/
	for(i=0;i<(ul_dly_ticks*100);i++)
	{
		nop();
	}
}

static void imu_interrupt_handler(uint32_t id, uint32_t mask)
{
	if ((IMU_INTERRUPT_ID == id) && (IMU_INTERRUPT_PIN_MSK == mask)) {
		//printf("Interrupt call back\r\n");
	}
}

void InitialiseI2C()
{
	ioport_set_pin_dir(GPIO_IMU_INTERRUPT, IOPORT_DIR_INPUT);
	ioport_set_pin_mode(GPIO_IMU_INTERRUPT, GPIO_IMU_INTERRUPT_FLAGS);
	ioport_set_pin_sense_mode(GPIO_IMU_INTERRUPT, GPIO_IMU_INTERRUPT_SENSE);
	
	/* Configure PIO clock. */
	pmc_enable_periph_clk(IMU_INTERRUPT_ID);

	/* Adjust pio debounce filter parameters, uses 10 Hz filter. */
	pio_set_debounce_filter(IMU_INTERRUPT_PIO, IMU_INTERRUPT_PIN_MSK, 10);

	/* Initialize pios interrupt handlers, see PIO definition in board.h. */
	pio_handler_set(IMU_INTERRUPT_PIO, IMU_INTERRUPT_ID, IMU_INTERRUPT_PIN_MSK,
	IMU_INTERRUPT_ATTR, imu_interrupt_handler);

	/* Enable PIO controller IRQs. */
	NVIC_EnableIRQ((IRQn_Type)IMU_INTERRUPT_ID);

	/* Enable PIO line interrupts. */
	pio_enable_interrupt(IMU_INTERRUPT_PIO, IMU_INTERRUPT_PIN_MSK);
	
	/* Enable the peripheral clock for TWI */
	pmc_enable_periph_clk(ID_TWIHS0);
	
}

uint32_t i2c_write(Twihs *p_twihs, uint8_t chip_addr, uint32_t mem_addr, uint32_t mem_addr_length, void *buffer, uint32_t buffer_length)
{
		twihs_packet_t packet_tx;
		uint32_t ret;
		
		/* Configure the data packet to be transmitted */
		packet_tx.chip        = chip_addr;
		packet_tx.addr[0]     = (uint8_t)mem_addr;
		packet_tx.addr[1]     = (uint8_t)(mem_addr >> 8);
		packet_tx.addr_length = mem_addr_length;
		packet_tx.buffer      = buffer;
		packet_tx.length      = buffer_length;
				
		ret =  twihs_master_write(p_twihs, &packet_tx);
		/* Wait at least 10 ms */ // Handle it with Rtos Delay in case of Freertos mode 
		mdelay(WAIT_TIME);
		//vTaskDelay(10000);
		
		return ret;
}

uint32_t i2c_read(Twihs *p_twihs, uint8_t chip_addr, uint32_t mem_addr, uint32_t mem_addr_length, void *buffer, uint32_t buffer_length)
{
	twihs_packet_t packet_rx;
	
	/* Configure the data packet to be transmitted */
	packet_rx.chip        = chip_addr;
	packet_rx.addr[0]     = (uint8_t)mem_addr;
	packet_rx.addr[1]     = (uint8_t)(mem_addr >> 8);
	packet_rx.addr_length = mem_addr_length;
	packet_rx.buffer      = buffer;
	packet_rx.length      = buffer_length;
	
	return twihs_master_read(p_twihs, &packet_rx);
}

void MPU6050_Read_Accel(Twihs *p_twihs, MPU6050_t *DataStruct)
{
    uint8_t Rec_Data[6];
	//uint32_t ret;
    // Read 6 BYTES of data starting from ACCEL_XOUT_H register
	for(int i = 0; i<6; i++)
     i2c_read(p_twihs, MPU6050_ADDR, ACCEL_XOUT_H_REG, 1, &Rec_Data[i], 1);
    DataStruct->Accel_X_RAW = (int16_t)(Rec_Data[0] << 8 | Rec_Data[1]);
    DataStruct->Accel_Y_RAW = (int16_t)(Rec_Data[2] << 8 | Rec_Data[3]);
    DataStruct->Accel_Z_RAW = (int16_t)(Rec_Data[4] << 8 | Rec_Data[5]);
    /*** convert the RAW values into acceleration in 'g'
         we have to divide according to the Full scale value set in FS_SEL
         I have configured FS_SEL = 0. So I am dividing by 16384.0
         for more details check ACCEL_CONFIG Register              ****/

    DataStruct->Ax = DataStruct->Accel_X_RAW / 16384.0;
    DataStruct->Ay = DataStruct->Accel_Y_RAW / 16384.0;
    DataStruct->Az = DataStruct->Accel_Z_RAW / Accel_Z_corrector;
}

void MPU6050_Read_Gyro(Twihs *p_twihs, MPU6050_t *DataStruct)
{
    uint8_t Rec_Data[6];
    // Read 6 BYTES of data starting from GYRO_XOUT_H register
	for(int i = 0; i<6; i++)
    i2c_read(p_twihs, MPU6050_ADDR, GYRO_XOUT_H_REG, 1, &Rec_Data[i], 1);
    DataStruct->Gyro_X_RAW = (int16_t)(Rec_Data[0] << 8 | Rec_Data[1]);
    DataStruct->Gyro_Y_RAW = (int16_t)(Rec_Data[2] << 8 | Rec_Data[3]);
    DataStruct->Gyro_Z_RAW = (int16_t)(Rec_Data[4] << 8 | Rec_Data[5]);
    /*** convert the RAW values into dps (?/s)
         we have to divide according to the Full scale value set in FS_SEL
         I have configured FS_SEL = 0. So I am dividing by 131.0
         for more details check GYRO_CONFIG Register              ****/
    DataStruct->Gx = DataStruct->Gyro_X_RAW / 131.0;
    DataStruct->Gy = DataStruct->Gyro_Y_RAW / 131.0;
    DataStruct->Gz = DataStruct->Gyro_Z_RAW / 131.0;
}

void MPU6050_Read_Temp(Twihs *p_twihs, MPU6050_t *DataStruct) 
{
    uint8_t Rec_Data[2];
    int16_t temp;
    // Read 2 BYTES of data starting from TEMP_OUT_H_REG register
	for(int i = 0; i<2; i++)
    i2c_read(p_twihs, MPU6050_ADDR, TEMP_OUT_H_REG, 1, &Rec_Data[i], 1);
    temp = (int16_t) (Rec_Data[0] << 8 | Rec_Data[1]);
    DataStruct->Temperature = (float) ((int16_t) temp / (float) 340.0 + (float) 36.53);
}


// Accelerometer and gyroscope self test; check calibration wrt factory settings
void MPU6050SelfTest(float * destination) // Should return percent deviation from factory trim values, +/- 14 or less deviation is a pass
{
   uint8_t rawData[4];
   uint8_t selfTest[6];
   float factoryTrim[6];
   uint8_t Data = 0;
   // Configure the accelerometer for self-test
   Data = 0xF0;
   i2c_write(TWIHS0, MPU6050_ADDR, ACCEL_CONFIG_REG, 1, &Data, 1); // Enable self test on all three axes and set accelerometer range to +/- 8 g
   
   Data = 0xE0; 
   i2c_write(TWIHS0, MPU6050_ADDR, GYRO_CONFIG_REG, 1, &Data, 1); // Enable self test on all three axes and set gyro range to +/- 250 degrees/s
   
   mdelay(250);  // Delay a while to let the device execute the self-test

   i2c_read(TWIHS0, MPU6050_ADDR, SELF_TEST_X, 1, &rawData[0], 1);// X-axis self-test results
   i2c_read(TWIHS0, MPU6050_ADDR, SELF_TEST_Y, 1, &rawData[1], 1);// Y-axis self-test results
   i2c_read(TWIHS0, MPU6050_ADDR, SELF_TEST_Z, 1, &rawData[2], 1);// Z-axis self-test results
   i2c_read(TWIHS0, MPU6050_ADDR, SELF_TEST_A, 1, &rawData[3], 1);// A-axis self-test results

   // Extract the acceleration test results first
   selfTest[0] = (rawData[0] >> 3) | (rawData[3] & 0x30) >> 4 ; // XA_TEST result is a five-bit unsigned integer
   selfTest[1] = (rawData[1] >> 3) | (rawData[3] & 0x0C) >> 2 ; // YA_TEST result is a five-bit unsigned integer
   selfTest[2] = (rawData[2] >> 3) | (rawData[3] & 0x03) >> 0 ; // ZA_TEST result is a five-bit unsigned integer
   // Extract the gyration test results first
   selfTest[3] = rawData[0]  & 0x1F ; // XG_TEST result is a five-bit unsigned integer
   selfTest[4] = rawData[1]  & 0x1F ; // YG_TEST result is a five-bit unsigned integer
   selfTest[5] = rawData[2]  & 0x1F ; // ZG_TEST result is a five-bit unsigned integer   
   // Process results to allow final comparison with factory set values
   factoryTrim[0] = (4096.0*0.34)*(pow( (0.92/0.34) , (((float)selfTest[0] - 1.0)/30.0))); // FT[Xa] factory trim calculation
   factoryTrim[1] = (4096.0*0.34)*(pow( (0.92/0.34) , (((float)selfTest[1] - 1.0)/30.0))); // FT[Ya] factory trim calculation
   factoryTrim[2] = (4096.0*0.34)*(pow( (0.92/0.34) , (((float)selfTest[2] - 1.0)/30.0))); // FT[Za] factory trim calculation
   factoryTrim[3] =  ( 25.0*131.0)*(pow( 1.046 , ((float)selfTest[3] - 1.0) ));             // FT[Xg] factory trim calculation
   factoryTrim[4] =  (-25.0*131.0)*(pow( 1.046 , ((float)selfTest[4] - 1.0) ));             // FT[Yg] factory trim calculation
   factoryTrim[5] =  ( 25.0*131.0)*(pow( 1.046 , ((float)selfTest[5] - 1.0) ));             // FT[Zg] factory trim calculation
   
	// Report results as a ratio of (STR - FT)/FT; the change from Factory Trim of the Self-Test Response
	// To get to percent, must multiply by 100 and subtract result from 100
   for (int i = 0; i < 6; i++) {
     destination[i] = 100.0 + 100.0*((float)selfTest[i] - factoryTrim[i])/factoryTrim[i]; // Report percent differences
   }
}

void initMPU6050(void)
{  
#if 1	
	// Initialize MPU6050 device
	uint8_t Data;
	uint32_t ret;
	//  wake up device-don't need this here if using calibration function below
    Data = 0x00;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, PWR_MGMT_1_REG, 1, &Data, 1); // Clear sleep mode bit (6), enable all sensors 
	mdelay(100); // Delay 100 ms for PLL to get established on x-axis gyro; should check for PLL ready interrupt  

	// get stable time source
    Data = 0x01;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, PWR_MGMT_1_REG, 1, &Data, 1);   // Set clock source to be PLL with x-axis gyroscope reference, bits 2:0 = 001

	// Configure Gyro and Accelerometer
	// Disable FSYNC and set accelerometer and gyro bandwidth to 44 and 42 Hz, respectively; 
	// DLPF_CFG = bits 2:0 = 010; this sets the sample rate at 1 kHz for both
    Data = 0x03;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, CONFIG, 1, &Data, 1);

	// Set sample rate = gyroscope output rate/(1 + SMPLRT_DIV)
    Data = 0x03;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, SMPLRT_DIV, 1, &Data, 1);  // Use a 200 Hz sample rate 
 
	 // Set gyroscope full scale range
	 // Range selects FS_SEL and AFS_SEL are 0 - 3, so 2-bit values are left-shifted into positions 4:3
	uint8_t c = 0;
	i2c_read(TWIHS0, MPU6050_ADDR, GYRO_CONFIG_REG, 1, &c, 1);
    Data = c & ~0xE0;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, GYRO_CONFIG_REG, 1, &Data, 1);// Clear self-test bits [7:5] 
	Data = c & ~0x18;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, GYRO_CONFIG_REG, 1, &Data, 1); // Clear AFS bits [4:3]
	Data = c | Gscale << 3;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, GYRO_CONFIG_REG, 1, &Data, 1);// Set full scale range for the gyro
	  
	// Set accelerometer configuration
	i2c_read(TWIHS0, MPU6050_ADDR, GYRO_CONFIG_REG, 1, &c, 1);
    Data = c & ~0xE0;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, ACCEL_CONFIG_REG, 1, &Data, 1);// Clear self-test bits [7:5] 
	Data = c & ~0x18;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, ACCEL_CONFIG_REG, 1, &Data, 1); // Clear AFS bits [4:3]
	Data = c | Ascale << 3;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, ACCEL_CONFIG_REG, 1, &Data, 1);// Set full scale range for the accelerometer 

	// Configure Interrupts and Bypass Enable
	// Set interrupt pin active high, push-pull, and clear on read of INT_STATUS, enable I2C_BYPASS_EN so additional chips 
	// can join the I2C bus and all can be controlled by the TWI as master
    Data = 0x02;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, INT_PIN_CFG, 1, &Data, 1);
    Data = 0x01;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, INT_ENABLE, 1, &Data, 1);// Enable data ready (bit 0) interrupt	

#else		
    uint8_t check;
    uint8_t Data;
	uint32_t ret;
	
    // power management register 0X6B we should write all 0's to wake the sensor up
    Data = 0;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, PWR_MGMT_1_REG, 1, &Data, 1);
	
    // Set DATA RATE of 1KHz by writing SMPLRT_DIV register
    Data = 0x07;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, SMPLRT_DIV_REG, 1, &Data, 1);

    Data = 1;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, PWR_MGMT_1_REG, 1, &Data, 1);
			
    // Set accelerometer configuration in ACCEL_CONFIG Register
    // XA_ST=0,YA_ST=0,ZA_ST=0, FS_SEL=0 -> ? 2g
    Data = 0x00;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, ACCEL_CONFIG_REG, 1, &Data, 1);

    // Set Gyroscopic configuration in GYRO_CONFIG Register
    // XG_ST=0,YG_ST=0,ZG_ST=0, FS_SEL=0 -> ? 250 ?/s
    Data = 0x00;
    ret = i2c_write(TWIHS0, MPU6050_ADDR, GYRO_CONFIG_REG, 1, &Data, 1);
#endif		
}


// Function which accumulates gyro and accelerometer data after device initialization. It calculates the average
// of the at-rest readings and then loads the resulting offsets into accelerometer and gyro bias registers.
void calibrateMPU6050(float * dest1, float * dest2)
{  
	uint8_t data[12]; // data array to hold accelerometer and gyro x, y, z, data
	uint16_t ii, packet_count, fifo_count;
	int32_t gyro_bias[3] = {0, 0, 0}, accel_bias[3] = {0, 0, 0};
  
	uint8_t Data = 0;
	uint32_t ret = 0;
	
	// reset device, reset all registers, clear gyro and accelerometer bias registers
	Data = 0x80;
	ret = i2c_write(TWIHS0, MPU6050_ADDR, PWR_MGMT_1_REG, 1, &Data, 1); // Write a one to bit 7 reset bit; toggle reset device
	mdelay(100);  
   
	// get stable time source
	// Set clock source to be PLL with x-axis gyroscope reference, bits 2:0 = 001
	Data = 0x01;
	ret = i2c_write(TWIHS0, MPU6050_ADDR, PWR_MGMT_1_REG, 1, &Data, 1);  
	Data = 0x00;
	ret = i2c_write(TWIHS0, MPU6050_ADDR, PWR_MGMT_2_REG, 1, &Data, 1);
	mdelay(200);
  
	// Configure device for bias calculation
	Data = 0x00;
	ret = i2c_write(TWIHS0, MPU6050_ADDR, INT_ENABLE, 1, &Data, 1);// Disable all interrupts
	Data = 0x00;
	ret = i2c_write(TWIHS0, MPU6050_ADDR, FIFO_EN, 1, &Data, 1);  // Disable FIFO	
	Data = 0x00;
	ret = i2c_write(TWIHS0, MPU6050_ADDR, PWR_MGMT_1_REG, 1, &Data, 1);// Turn on internal clock source
	Data = 0x00;
	ret = i2c_write(TWIHS0, MPU6050_ADDR, I2C_MST_CTRL, 1, &Data, 1); // Disable I2C master
	Data = 0x00;
	ret = i2c_write(TWIHS0, MPU6050_ADDR, USER_CTRL, 1, &Data, 1);// Disable FIFO and I2C master modes
	Data = 0x00;
	ret = i2c_write(TWIHS0, MPU6050_ADDR, USER_CTRL, 1, &Data, 1); // Reset FIFO and DMP
	mdelay(15);
  
	// Configure MPU6050 gyro and accelerometer for bias calculation
	Data = 0x01;
	ret = i2c_write(TWIHS0, MPU6050_ADDR, CONFIG, 1, &Data, 1);// Set low-pass filter to 188 Hz
	Data = 0x00;
	ret = i2c_write(TWIHS0, MPU6050_ADDR, SMPLRT_DIV, 1, &Data, 1); // Set sample rate to 1 kHz
	Data = 0x00;
	ret = i2c_write(TWIHS0, MPU6050_ADDR, GYRO_CONFIG_REG, 1, &Data, 1);// Set gyro full-scale to 250 degrees per second, maximum sensitivity
	Data = 0x00;
	ret = i2c_write(TWIHS0, MPU6050_ADDR, ACCEL_CONFIG_REG, 1, &Data, 1);// Set accelerometer full-scale to 2 g, maximum sensitivity
 
	uint16_t  gyrosensitivity  = 131;   // = 131 LSB/degrees/sec
	uint16_t  accelsensitivity = 16384;  // = 16384 LSB/g

	// Configure FIFO to capture accelerometer and gyro data for bias calculation
	Data = 0x40;
	ret = i2c_write(TWIHS0, MPU6050_ADDR, USER_CTRL, 1, &Data, 1);	 // Enable FIFO 
	Data = 0x78;
	ret = i2c_write(TWIHS0, MPU6050_ADDR, FIFO_EN, 1, &Data, 1); // Enable gyro and accelerometer sensors for FIFO  (max size 1024 bytes in MPU-6050)
	mdelay(80); // accumulate 80 samples in 80 milliseconds = 960 bytes

	// At end of sample accumulation, turn off FIFO sensor read
	Data = 0x00;
	ret = i2c_write(TWIHS0, MPU6050_ADDR, FIFO_EN, 1, &Data, 1);// Disable gyro and accelerometer sensors for FIFO
	memset(data, 0, sizeof(data));
	for(int i = 0; i<2; i++)
	ret = i2c_read(TWIHS0, MPU6050_ADDR, FIFO_COUNTH, 1, &data[i], 1);	// read FIFO sample count
	fifo_count = ((uint16_t)data[0] << 8) | data[1];
	packet_count = fifo_count/12;// How many sets of full gyro and accelerometer data for averaging

	for (ii = 0; ii < packet_count; ii++) {
	int16_t accel_temp[3] = {0, 0, 0}, gyro_temp[3] = {0, 0, 0};
	memset(data, 0, sizeof(data));
	for(int i = 0; i<12; i++)
	ret = i2c_read(TWIHS0, MPU6050_ADDR, FIFO_R_W, 1, &data[i], 1);	// read data for averaging
	accel_temp[0] = (int16_t) (((int16_t)data[0] << 8) | data[1]  ) ;  // Form signed 16-bit integer for each sample in FIFO
	accel_temp[1] = (int16_t) (((int16_t)data[2] << 8) | data[3]  ) ;
	accel_temp[2] = (int16_t) (((int16_t)data[4] << 8) | data[5]  ) ;    
	gyro_temp[0]  = (int16_t) (((int16_t)data[6] << 8) | data[7]  ) ;
	gyro_temp[1]  = (int16_t) (((int16_t)data[8] << 8) | data[9]  ) ;
	gyro_temp[2]  = (int16_t) (((int16_t)data[10] << 8) | data[11]) ;
    
	accel_bias[0] += (int32_t) accel_temp[0]; // Sum individual signed 16-bit biases to get accumulated signed 32-bit biases
	accel_bias[1] += (int32_t) accel_temp[1];
	accel_bias[2] += (int32_t) accel_temp[2];
	gyro_bias[0]  += (int32_t) gyro_temp[0];
	gyro_bias[1]  += (int32_t) gyro_temp[1];
	gyro_bias[2]  += (int32_t) gyro_temp[2];
            
	}
	accel_bias[0] /= (int32_t) packet_count; // Normalize sums to get average count biases
	accel_bias[1] /= (int32_t) packet_count;
	accel_bias[2] /= (int32_t) packet_count;
	gyro_bias[0]  /= (int32_t) packet_count;
	gyro_bias[1]  /= (int32_t) packet_count;
	gyro_bias[2]  /= (int32_t) packet_count;
    
	if(accel_bias[2] > 0L) {accel_bias[2] -= (int32_t) accelsensitivity;}  // Remove gravity from the z-axis accelerometer bias calculation
	else {accel_bias[2] += (int32_t) accelsensitivity;}
 
	// Construct the gyro biases for push to the hardware gyro bias registers, which are reset to zero upon device startup
	data[0] = (-gyro_bias[0]/4  >> 8) & 0xFF; // Divide by 4 to get 32.9 LSB per deg/s to conform to expected bias input format
	data[1] = (-gyro_bias[0]/4)       & 0xFF; // Biases are additive, so change sign on calculated average gyro biases
	data[2] = (-gyro_bias[1]/4  >> 8) & 0xFF;
	data[3] = (-gyro_bias[1]/4)       & 0xFF;
	data[4] = (-gyro_bias[2]/4  >> 8) & 0xFF;
	data[5] = (-gyro_bias[2]/4)       & 0xFF;

	// Push gyro biases to hardware registers; works well for gyro but not for accelerometer
	//  writeByte(MPU6050_ADDRESS, XG_OFFS_USRH, data[0]); 
	//  writeByte(MPU6050_ADDRESS, XG_OFFS_USRL, data[1]);
	//  writeByte(MPU6050_ADDRESS, YG_OFFS_USRH, data[2]);
	//  writeByte(MPU6050_ADDRESS, YG_OFFS_USRL, data[3]);
	//  writeByte(MPU6050_ADDRESS, ZG_OFFS_USRH, data[4]);
	//  writeByte(MPU6050_ADDRESS, ZG_OFFS_USRL, data[5]);

	dest1[0] = (float) gyro_bias[0]/(float) gyrosensitivity; // construct gyro bias in deg/s for later manual subtraction
	dest1[1] = (float) gyro_bias[1]/(float) gyrosensitivity;
	dest1[2] = (float) gyro_bias[2]/(float) gyrosensitivity;

	// Construct the accelerometer biases for push to the hardware accelerometer bias registers. These registers contain
	// factory trim values which must be added to the calculated accelerometer biases; on boot up these registers will hold
	// non-zero values. In addition, bit 0 of the lower byte must be preserved since it is used for temperature
	// compensation calculations. Accelerometer bias registers expect bias input as 2048 LSB per g, so that
	// the accelerometer biases calculated above must be divided by 8.

	int32_t accel_bias_reg[3] = {0, 0, 0}; // A place to hold the factory accelerometer trim biases
	memset(data, 0, sizeof(data));
	for(int i = 0; i<2; i++)	
	ret = i2c_read(TWIHS0, MPU6050_ADDR, XA_OFFSET_H, 1, &data[i], 1);		// Read factory accelerometer trim values	
	accel_bias_reg[0] = (int16_t) ((int16_t)data[0] << 8) | data[1];
	for(int i = 0; i<2; i++)	
	ret = i2c_read(TWIHS0, MPU6050_ADDR, YA_OFFSET_H, 1, &data[i], 1);	
	memset(data, 0, sizeof(data));
	accel_bias_reg[1] = (int16_t) ((int16_t)data[0] << 8) | data[1];
	memset(data, 0, sizeof(data));
	for(int i = 0; i<2; i++)		
	ret = i2c_read(TWIHS0, MPU6050_ADDR, ZA_OFFSET_H, 1, &data[i], 1);		
	accel_bias_reg[2] = (int16_t) ((int16_t)data[0] << 8) | data[1];
  
	uint32_t mask = 1uL; // Define mask for temperature compensation bit 0 of lower byte of accelerometer bias registers
	uint8_t mask_bit[3] = {0, 0, 0}; // Define array to hold mask bit for each accelerometer bias axis
  
	for(ii = 0; ii < 3; ii++) {
	if(accel_bias_reg[ii] & mask) mask_bit[ii] = 0x01; // If temperature compensation bit is set, record that fact in mask_bit
	}

	// Construct total accelerometer bias, including calculated average accelerometer bias from above
	accel_bias_reg[0] -= (accel_bias[0]/8); // Subtract calculated averaged accelerometer bias scaled to 2048 LSB/g (16 g full scale)
	accel_bias_reg[1] -= (accel_bias[1]/8);
	accel_bias_reg[2] -= (accel_bias[2]/8);
 
	data[0] = (accel_bias_reg[0] >> 8) & 0xFF;
	data[1] = (accel_bias_reg[0])      & 0xFF;
	data[1] = data[1] | mask_bit[0]; // preserve temperature compensation bit when writing back to accelerometer bias registers
	data[2] = (accel_bias_reg[1] >> 8) & 0xFF;
	data[3] = (accel_bias_reg[1])      & 0xFF;
	data[3] = data[3] | mask_bit[1]; // preserve temperature compensation bit when writing back to accelerometer bias registers
	data[4] = (accel_bias_reg[2] >> 8) & 0xFF;
	data[5] = (accel_bias_reg[2])      & 0xFF;
	data[5] = data[5] | mask_bit[2]; // preserve temperature compensation bit when writing back to accelerometer bias registers

	// Push accelerometer biases to hardware registers; doesn't work well for accelerometer
	// Are we handling the temperature compensation bit correctly?
	//  writeByte(MPU6050_ADDRESS, XA_OFFSET_H, data[0]);  
	//  writeByte(MPU6050_ADDRESS, XA_OFFSET_L_TC, data[1]);
	//  writeByte(MPU6050_ADDRESS, YA_OFFSET_H, data[2]);
	//  writeByte(MPU6050_ADDRESS, YA_OFFSET_L_TC, data[3]);  
	//  writeByte(MPU6050_ADDRESS, ZA_OFFSET_H, data[4]);
	//  writeByte(MPU6050_ADDRESS, ZA_OFFSET_L_TC, data[5]);

	// Output scaled accelerometer biases for manual subtraction in the main program
	dest2[0] = (float)accel_bias[0]/(float)accelsensitivity; 
	dest2[1] = (float)accel_bias[1]/(float)accelsensitivity;
	dest2[2] = (float)accel_bias[2]/(float)accelsensitivity;
}

void getGres(void) {
	switch (Gscale)
	{
		// Possible gyro scales (and their register bit settings) are:
		// 250 DPS (00), 500 DPS (01), 1000 DPS (10), and 2000 DPS  (11).
		case GFS_250DPS:
		gRes = 250.0/32768.0;
		break;
		case GFS_500DPS:
		gRes = 500.0/32768.0;
		break;
		case GFS_1000DPS:
		gRes = 1000.0/32768.0;
		break;
		case GFS_2000DPS:
		gRes = 2000.0/32768.0;
		break;
	}
}

void getAres(void) {
	switch (Ascale)
	{
		// Possible accelerometer scales (and their register bit settings) are:
		// 2 Gs (00), 4 Gs (01), 8 Gs (10), and 16 Gs  (11).
		case AFS_2G:
		aRes = 2.0/32768.0;
		break;
		case AFS_4G:
		aRes = 4.0/32768.0;
		break;
		case AFS_8G:
		aRes = 8.0/32768.0;
		break;
		case AFS_16G:
		aRes = 16.0/32768.0;
		break;
	}
}

void readAccelData(int16_t * destination)
{
	uint32_t ret = 0;
	uint8_t rawData[6];  // x/y/z accel register data stored here
	for(int i=0; i<5; i++)
	ret = i2c_read(TWIHS0, MPU6050_ADDR, ACCEL_XOUT_H, 1, &rawData[i], 1); //Read the six raw data registers into data array
	destination[0] = (int16_t)((rawData[0] << 8) | rawData[1]) ;  // Turn the MSB and LSB into a signed 16-bit value
	destination[1] = (int16_t)((rawData[2] << 8) | rawData[3]) ;
	destination[2] = (int16_t)((rawData[4] << 8) | rawData[5]) ;
}

void readGyroData(int16_t * destination)
{
	uint32_t ret = 0;
	uint8_t rawData[6];  // x/y/z gyro register data stored here
	for(int i=0; i<5; i++)
	ret = i2c_read(TWIHS0, MPU6050_ADDR, GYRO_XOUT_H, 1, &rawData[i], 1);// Read the six raw data registers sequentially into data array
	destination[0] = (int16_t)((rawData[0] << 8) | rawData[1]) ;  // Turn the MSB and LSB into a signed 16-bit value
	destination[1] = (int16_t)((rawData[2] << 8) | rawData[3]) ;
	destination[2] = (int16_t)((rawData[4] << 8) | rawData[5]) ;
}

int16_t readTempData()
{
	uint32_t ret = 0;
	uint8_t rawData[2];  // x/y/z temp register data stored here
	for(int i=0; i<2; i++)
	ret = i2c_read(TWIHS0, MPU6050_ADDR, TEMP_OUT_H, 1, &rawData[i], 1);// Read the two raw data registers sequentially into data array
	return ((int16_t)rawData[0]) << 8 | rawData[1] ;  // Turn the MSB and LSB into a 16-bit value
}

void SelfTest_MPU6050()
{
	twihs_options_t opt;
	/* Configure the options of TWI driver */
	opt.master_clk = sysclk_get_peripheral_hz();
	opt.speed      = TWIHS_CLK;

	if (twihs_master_init(TWIHS0, &opt) != TWIHS_SUCCESS) {
		puts("-E-\tTWI master initialization failed.\r");
		while (1) {
			/* Capture error */
		}
	}
		//print I2C address of all the device connected
	for(int i = 0; i<128; i++)
	{
		uint32_t ret = twihs_probe(TWIHS0, i);
		//if(ret == TWIHS_SUCCESS)
		//printf("I2C Addr = 0x%02x\r\n", i);
	}
	uint8_t device_id = 0;
	if (i2c_read(TWIHS0, MPU6050_ADDR, WHO_AM_I_REG, 1, &device_id, 1) != TWIHS_SUCCESS)
	{
		printf("read device ID Failed\r\n");
		//delay_ms(5000);
		//rstc_start_software_reset(RSTC);
	}
	else
	{
		//printf("Device ID is = 0x%02x\r\n", device_id);
		if(device_id == 0x68)
		{
			MPU6050SelfTest(SelfTest); // Start by performing self test and reporting values
			/*printf("x-axis self test: acceleration trim within : %f %% of factory value\r\n", SelfTest[0]);
			printf("y-axis self test: acceleration trim within : %f %% of factory value\r\n", SelfTest[1]);
			printf("z-axis self test: acceleration trim within : %f %% of factory value\r\n", SelfTest[2]);
			printf("x-axis self test: gyration trim within : %f %% of factory value\r\n", SelfTest[3]);
			printf("y-axis self test: gyration trim within : %f %% of factory value\r\n", SelfTest[4]);
			printf("z-axis self test: gyration trim within : %f %% of factory value\r\n", SelfTest[5]);*/
			
			if(SelfTest[0] < 1.0f && SelfTest[1] < 1.0f && SelfTest[2] < 1.0f && SelfTest[3] < 1.0f && SelfTest[4] < 1.0f && SelfTest[5] < 1.0f)
			{
				//printf("Pass Self-test!\r\n");
				IsIMUInitalised = true;
				delay_ms(1000);
				calibrateMPU6050(gyroBias, accelBias); // Calibrate gyro and accelerometers, load biases in bias registers
				initMPU6050();
				//printf("MPU6050 initialized for active data mode....\r\n"); // Initialize device for active mode read of acclerometer, gyroscope, and temperature
			}
			else
			{
				printf("Fail Self-test!\r\n");
				//while(1) ; // Loop forever if communication doesn't happen
			}
		}
		else
		{
			printf("read device ID is Wrong!\r\n");
			//while(1) ; // Loop forever if communication doesn't happen
		}
	}
}

void GetIMUReadings()
{
	uint8_t c = 1;
	i2c_read(TWIHS0, MPU6050_ADDR, INT_STATUS, 1, &c, 1);
	if(c & 0x01)
	{
		readAccelData(accelCount);  // Read the x/y/z adc values
		getAres();
		// Now we'll calculate the accleration value into actual g's
		ax = (double)accelCount[0]*aRes - accelBias[0];  // get actual g value, this depends on scale being set
		ay = (double)accelCount[1]*aRes - accelBias[1];
		az = (double)accelCount[2]*aRes - accelBias[2];
		//printf("Accelerometer values are %f, %f, %f\r\n", ax,ay,az);
		readGyroData(gyroCount);  // Read the x/y/z adc values
		getGres();
		
		// Calculate the gyro value into actual degrees per second
		gyrox = (float)gyroCount[0]*gRes - gyroBias[0];  // get actual gyro value, this depends on scale being set
		gyroy = (float)gyroCount[1]*gRes - gyroBias[1];
		gyroz = (float)gyroCount[2]*gRes - gyroBias[2];
		//printf("Gyroscope values are %2f, %2f, %2f\r\n", gyrox,gyroy,gyroz);
		tempCount = readTempData();  // Read the x/y/z adc values
		temperature = ((float)tempCount) / 340. + 36.53; // Temperature in degrees Centigrade

		printf("Temp: %f\r\n", temperature);// Print T values to tenths of s degree C
		printf("Axyz: %f %f %f \r\n", ax, ay, az);	// Print acceleration values in g
		printf("Gxzy: %f %f %f \r\n", gyrox, gyroy, gyroz);// Print gyro values in degree/sec
		return 0;
	}
}